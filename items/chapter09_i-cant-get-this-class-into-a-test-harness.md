# 9장. 이 클래스를 테스트 *harness*에서 못 쓰겠어요
*(I Can’t Get This Class into a Test Harness)*

자주 겪는 문제들

* 쉽게 객체를 생성할 수 없는 클래스
* 테스트 코드 컴파일을 어렵게 만드는 클래스
* 나쁜 부작용을 가지고 있는 생성자
* 생성자 내에서 일어나는 중요한 동작을 테스트를 감지해야 하는 상황

이 장에서는 위와 같은 문제들을 해결하는 다양한 의존성 제거 기법와 그 응용 방법을 여러 사례를 들어 소개한다.

## 귀찮은(irritating) 파라미터

테스트 *harness* 내에서 특정 클래스의 객체 생성에 문제가 있을지 확인해보는 가장 좋은 방법은 한 번 해보는 것이다. 아무 인자 없이 객체 생성만 하는 테스트 메써드(생성 테스트)를 작성해서 실행해본다. 이 메써드는 목적을 다하면 제거해도 무방하다.

테스트 대상 객체를 생성할 때 네트워크 연결이 필요한 객체를 인자로 넘겨주는 것은 바람직하지 않다.

* *Extract Interface* 같은 기법을 사용하여 가짜 객체로 대체하는 것이 좋다.
* 소수의 메써드만 다르게 동작시키는 것으로 충분하다면 *Subclass and Override Method* 기법을 사용할 수 있다. 단, 테스트 하려는 동작에 영향을 주지는 않는지 주의가 필요하다.

생성자에 *Null*을 인자로 넘겨보는 것도 괜찮은 방법이다. 테스트 실행 과정에서 사용되는 파라미터라서 테스트 실행 중에 에러가 발생한다면 제대로 된 객체를 넘겨주도록 테스트를 수정하면 된다. 단, 이 방법은 C나 C++에서는 사용하기 어렵다. (*Null* 값으로 인해 프로세스가 비정상 종료되면 문제 지점을 찾기 어려움)

프로덕션 코드에서 *Null* 값을 의도적으로 사용하는 것은 좋지 않다. 대신 *Null* 객체 패턴을 고려하라. (사용할 때 주의가 필요함)

테스트 코드에 적용하는 기준은 프로덕션 코드에 적용하는 기준과 다르다. 테스트를 가능하게 하는 데 필요하다면, 추상화나 데이터 *encapsulation* 등은 잘 지켜지지 않아도 괜찮다. 하지만 테스트 코드도 깨끗해야(*clean*)한다. 즉, 이해하거나 수정하기 쉬워야 한다.

## 숨겨진 의존성

테스트 *harness* 내에서 접근하지 못하는 리소스를 생성자에서 이용하는 경우.

사용할 수 있는 기법

* *Parameterize Constructor*
    * 숨겨진 의존성을 밖으로 드러나게 만든다.
    * *Extract Interface* 등의 기법을 이용하여 생성자에 가짜 객체를 넘기는 게 가능해진다.
    * *Preserve Signature* 기법을 이용하여 테스트 없이 안전하게 변경할 수 있다.
    * *Wrap Method* 기법을 적용하면 기존 클라이언트 코드에 영향을 주지 않아도 된다.
* *Extract and Override Getter*
* *Extract and Override Factory Method*
* *Supersede Instance Variable*

## 객체를 잔뜩 생성하는 생성자

생성자 내에서 상당히 많은 객체를 생성하여 사용하고, 생성한 객체를 이용하여 또 다른 객체를 생성하는 일을 하고 있을 경우에는 *Parameterize Constructor*를 적용하기 어렵다.

대안들

* 생성자 내부 로직을 바깥으로 꺼낼 경우
    * 안전하게 변경하기 어렵다.
    * 클라이언트 코드에 많은 부담을 떠넘기는 형태다.
* *Extract and Override Factory Method* 기법
    * C++에서는 불가능하다.
    * 수퍼클래스가 제대로 초기화 되기 전에 서브클래스에서 오버라이드하는 메써드를 호출하는 것은 다른 언어에서도 위험하다.
* *Supersede Instance Variable* 기법
    * C++에서는 명시적으로 기존 필드 값을 제거해줄 필요가 있다. 다른 리소스에 영향을 주지는 않는지 주의를 기울여야 한다.
    * 프로덕션 코드에서 사용할 경우 심각한 버그를 유발할 수도 있다.
    * *Extract Interface*나 *Extract Implementer* 기법을 이용하면 가짜 객체를 인자로 넘겨주어 감지(*sensing*)에 활용할 수 있다.
    * 리소스 관리의 위험성 때문에 불가피한 경우가 아니면 다른 기법을 이용하는 것이 좋다.

## The Case of the Irritating Global Dependency

