# 9장. 이 클래스를 테스트 *harness*에서 못 쓰겠어요
*(I Can’t Get This Class into a Test Harness)*

자주 겪는 문제들

* 쉽게 객체를 생성할 수 없는 클래스
* 테스트 코드 컴파일을 어렵게 만드는 클래스
* 나쁜 부작용을 가지고 있는 생성자
* 생성자 내에서 일어나는 중요한 동작을 테스트를 감지해야 하는 상황

이 장에서는 위와 같은 문제들을 해결하는 다양한 의존성 제거 기법와 그 응용 방법을 여러 사례를 들어 소개한다.

## 귀찮은(irritating) 파라미터

테스트 *harness* 내에서 특정 클래스의 객체 생성에 문제가 있을지 확인해보는 가장 좋은 방법은 한 번 해보는 것이다. 아무 인자 없이 객체 생성만 하는 테스트 메써드(생성 테스트)를 작성해서 실행해본다. 이 메써드는 목적을 다하면 제거해도 무방하다.

테스트 대상 객체를 생성할 때 네트워크 연결이 필요한 객체를 인자로 넘겨주는 것은 바람직하지 않다.

* *Extract Interface* 같은 기법을 사용하여 가짜 객체로 대체하는 것이 좋다.
* 소수의 메써드만 다르게 동작시키는 것으로 충분하다면 *Subclass and Override Method* 기법을 사용할 수 있다. 단, 테스트 하려는 동작에 영향을 주지는 않는지 주의가 필요하다.

생성자에 *Null*을 인자로 넘겨보는 것도 괜찮은 방법이다. 테스트 실행 과정에서 사용되는 파라미터라서 테스트 실행 중에 에러가 발생한다면 제대로 된 객체를 넘겨주도록 테스트를 수정하면 된다. 단, 이 방법은 C나 C++에서는 사용하기 어렵다. (*Null* 값으로 인해 프로세스가 비정상 종료되면 문제 지점을 찾기 어려움)

프로덕션 코드에서 *Null* 값을 의도적으로 사용하는 것은 좋지 않다. 대신 *Null* 객체 패턴을 고려하라. (사용할 때 주의가 필요함)

테스트 코드에 적용하는 기준은 프로덕션 코드에 적용하는 기준과 다르다. 테스트를 가능하게 하는 데 필요하다면, 추상화나 데이터 *encapsulation* 등은 잘 지켜지지 않아도 괜찮다. 하지만 테스트 코드도 깨끗해야(*clean*)한다. 즉, 이해하거나 수정하기 쉬워야 한다.

## 숨겨진 의존성

테스트 *harness* 내에서 접근하지 못하는 리소스를 생성자에서 이용하는 경우.

사용할 수 있는 기법

* *Parameterize Constructor*
    * 숨겨진 의존성을 밖으로 드러나게 만든다.
    * *Extract Interface* 등의 기법을 이용하여 생성자에 가짜 객체를 넘기는 게 가능해진다.
    * *Preserve Signature* 기법을 이용하여 테스트 없이 안전하게 변경할 수 있다.
    * *Wrap Method* 기법을 적용하면 기존 클라이언트 코드에 영향을 주지 않아도 된다.
* *Extract and Override Getter*
* *Extract and Override Factory Method*
* *Supersede Instance Variable*

## 객체를 잔뜩 생성하는 생성자

생성자 내에서 상당히 많은 객체를 생성하여 사용하고, 생성한 객체를 이용하여 또 다른 객체를 생성하는 일을 하고 있을 경우에는 *Parameterize Constructor*를 적용하기 어렵다.

대안들

* 생성자 내부 로직을 바깥으로 꺼낼 경우
    * 안전하게 변경하기 어렵다.
    * 클라이언트 코드에 많은 부담을 떠넘기는 형태다.
* *Extract and Override Factory Method* 기법
    * C++에서는 불가능하다.
    * 수퍼클래스가 제대로 초기화 되기 전에 서브클래스에서 오버라이드하는 메써드를 호출하는 것은 다른 언어에서도 위험하다.
* *Supersede Instance Variable* 기법
    * C++에서는 명시적으로 기존 필드 값을 제거해줄 필요가 있다. 다른 리소스에 영향을 주지는 않는지 주의를 기울여야 한다.
    * 프로덕션 코드에서 사용할 경우 심각한 버그를 유발할 수도 있다.
    * *Extract Interface*나 *Extract Implementer* 기법을 이용하면 가짜 객체를 인자로 넘겨주어 감지(*sensing*)에 활용할 수 있다.
    * 리소스 관리의 위험성 때문에 불가피한 경우가 아니면 다른 기법을 이용하는 것이 좋다.

## 성가신(Irritating) 전역 의존성

전역 변수가 나쁜 이유

* 불투명성
    - 코드를 일일이 따라가보지 않으면 내부에서 건드리고 있는 전역변수를 찾을 수 없다.
    - 테스트를 위한 초기화 작업이 어려워진다.
* 가짜 객체로 대체하기 어렵다.
* 전역 상태가 존재하므로, 테스트들을 서로 영향을 주지 않고 독립적으로 수행할 수 없다.

싱글턴 패턴이 정당한 경우

* 현실 세계를 모델링 하는 중이며, 실제로 현실에서 그 존재가 단 하나만 있는 경우
* 두 개 이상 객체를 생성하면 심각한 문제가 발생할 수 있는 경우
* 두 개 이상 객체를 생성하면 상당한 자원이 소모되는 경우

위와 같은 경우가 아니라, 단순히 전역 변수가 필요해서 싱글턴 패턴을 사용한 경우, 대부분 싱글턴 속성을 완화하거나 제거해도 괜찮다.

테스트를 위해 싱글턴 속성을 완화하는 방법으로 싱글턴 객체를 삭제하는 클래스 메써드를 제공하는 방법도 있지만, 싱글턴 객체를 가짜 객체로 대체시키는 것이 가능한 *Introduce Static Setter* 기법이 많이 쓰인다.

생성자는 public으로 선언할 수도 있고, 테스트용 서브클래스에서만 접근할 수 있도록 protected로 선언할 수도 있다. 테스트용 서브클래스 작성에는 다음과 같은 방식이 사용된다.

* *Subclass and Override Method*
* *Extract Interface*나 *Extract Implementer* (의존성이 광범위할 경우)

전역 의존성 문제를 제대로 해결하고 싶다면 *Introduce Static Setter* 대신 다음 기법을 사용하라.

* *Parameterized Method*: 단, 메써드 개수가 많아지므로 클래스를 이해하기 어려워질 수도 있음.
* *Parameterized Constructor*: 단, 필드가 개수가 많아지고, 객체를 생성하는 쪽 코드에서도 생성자에 전달할 객체에 접근할 수 있어야 함.

만약 어떤 전역 변수가 정말 거의 모든 곳에서 사용되고 있다면, 그것은 코드에 계층 구조가 없기 때문일 수 있다. 다음 내용을 참고하라.

* 15장, *My Application Is All API Calls*
* 17장, *My application Has No Structure*

## 끔찍한 *Include* 의존성

C++에서 테스트 *harness* 내에서 다루기 매우 어려운 라이브러리를 *include* 해야 하는 경우.

테스트 대상이 필요로 하는 심볼에 대해 별도의 테스트용 정의를 작성하는 방법을 사용할 수 있다. 나아가 이러한 정의들만 모아놓은 헤더 파일을 만들어 테스트 코드에서 재활용할 수도 있다.

하지만 다음과 같은 단점이 있기 때문에 거대한 클래스에 매우 심각한 의존성 문제가 있을 때만 사용하는 것이 좋다.

* 별도의 프로그램으로 빌드해야 함.
* 실제로는 의존성을 제거한 게 아님.
* 별도의 테스트용 정의를 계속 유지해야 함.

## *The Case of the Onion Parameter*
