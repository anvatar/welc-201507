# 9장. 이 클래스를 테스트 *harness*에서 못 쓰겠어요
*(I Can’t Get This Class into a Test Harness)*

자주 겪는 문제

* 쉽게 객체를 생성할 수 없는 클래스
* 테스트 코드 컴파일을 어렵게 만드는 클래스
* 나쁜 부작용을 가지고 있는 생성자
* 생성자 내에서 일어나는 중요한 동작을 감지해야 하는 상황

## 귀찮은(irritating) 파라미터

테스트 *harness* 내에서 특정 클래스의 객체를 문제 없이 생성할 수 있는지 확인해보는 가장 좋은 방법은 한 번 해보는 것이다. 아무 인자 없이 객체 생성만 하는 테스트 메써드를 실행해본다. 이 메써드는 목적을 다하면 제거한다.

테스트 대상 객체를 생성할 때 네트워크 연결이 필요한 객체를 인자로 넘겨주는 것은 바람직하지 않다.

* *Extract Interface* 같은 기법을 사용하여 가짜 객체로 대체하는 것이 좋다.
* 소수의 메써드만 다르게 동작시키는 것으로 충분하다면 *Subclass and Override Method* 기법을 사용할 수 있다. 단, 테스트 하려는 동작에 영향을 주지는 않는지 주의.

생성자에 *Null*을 인자로 넘겨보는 것도 괜찮은 방법이다. 테스트 실행 과정에서 사용되는 파라미터라서 테스트 실행 중에 에러가 발생한다면 제대로 된 객체를 넘겨주도록 테스트를 수정하면 된다. 단, 이 방법은 프로세스가 비정상 종료되면 문제 지점을 찾기 불편한 C나 C++에서는 사용하기 어렵다.

프로덕션 코드에서 *Null* 값을 의도적으로 사용하는 것은 좋지 않다. 대신 *Null* 객체 패턴을 고려하라. 기존 동작에 영향을 주지 않는지 주의해서 작업해야 한다.

테스트 코드에 적용하는 기준은 프로덕션 코드에 적용하는 기준과 다르다. 테스트를 가능하게 하는 데 필요하다면, 추상화나 데이터 *encapsulation* 등은 잘 지켜지지 않아도 괜찮다. 하지만 테스트 코드도 깨끗해야(*clean*)한다. 즉, 이해하거나 수정하기 쉬워야 한다.

## 숨겨진 의존성

테스트 *harness* 내에서 접근하지 못하는 리소스를 생성자에서 이용하는 경우:

* *Parameterize Constructor*: 숨겨진 의존성을 밖으로 드러나게 만든다.
    * *Extract Interface*: 생성자에 가짜 객체를 넘기는 게 가능
    * *Preserve Signature*: 테스트 없이 안전하게 변경
    * *Wrap Method*: 기존 클라이언트 코드에 영향 없이 변경
* *Extract and Override Getter*
* *Extract and Override Factory Method*
* *Supersede Instance Variable*

## 객체를 잔뜩 생성하는 생성자

생성자 내에서 상당히 많은 객체를 생성하여 사용하고, 생성한 객체를 이용하여 또 다른 객체를 생성하는 일을 하고 있을 경우에는 *Parameterize Constructor*를 적용하기 어렵다.

대안

* 생성자 내부 로직을 바깥으로 꺼낼 경우
    * 안전하게 변경하기 어렵다.
    * 클라이언트 코드에게 많은 부담을 준다.
* *Extract and Override Factory Method* 기법
    * C++에서는 불가능하다.
    * 수퍼클래스가 제대로 초기화 되기 전에 서브클래스에서 오버라이드하는 메써드를 호출하는 것은 다른 언어에서도 위험하다.
* *Supersede Instance Variable* 기법
    * C++에서는 명시적으로 기존 필드 값을 제거해줄 필요가 있다. 다른 리소스에 영향을 주지는 않는지 주의를 기울여야 한다.
    * 프로덕션 코드에서 사용할 경우 심각한 버그를 유발할 수도 있다.
    * *Extract Interface*나 *Extract Implementer* 기법을 이용하면 가짜 객체를 인자로 넘겨주어 감지(*sensing*)에 활용할 수 있다.
    * 리소스 관리의 위험성 때문에 불가피한 경우가 아니면 다른 기법을 이용하는 것이 좋다.

## 성가신(Irritating) 전역 의존성

전역 변수가 나쁜 이유

* 불투명성
    - 코드를 일일이 따라가보지 않으면 내부에서 건드리고 있는 전역변수를 찾을 수 없다.
    - 테스트를 위한 초기화 작업이 어려워진다.
* 가짜 객체로 대체하기 어렵다.
* 전역 상태가 존재하므로, 테스트들을 서로 영향을 주지 않고 독립적으로 수행할 수 없다.

싱글턴 패턴이 정당한 경우

* 현실 세계를 모델링 하는 중이며, 실제로 현실에서 그 존재가 단 하나만 있는 경우
* 두 개 이상 객체를 생성하면 심각한 문제가 발생할 수 있는 경우
* 두 개 이상 객체를 생성하면 상당한 자원이 소모되는 경우

위와 같은 경우가 아니라, 단순히 전역 변수가 필요해서 싱글턴 패턴을 사용한 경우라면 대부분 싱글턴 속성을 완화하거나 제거해도 괜찮다.

테스트를 위해 싱글턴 속성을 완화하는 방법으로 싱글턴 객체를 삭제하는 클래스 메써드를 제공하는 방법도 있지만, 싱글턴 객체를 가짜 객체로 대체시키는 것이 가능한 *Introduce Static Setter* 기법이 많이 쓰인다.

생성자는 public으로 선언할 수도 있고, 테스트용 서브클래스에서만 접근할 수 있도록 protected로 선언할 수도 있다. 테스트용 서브클래스 작성에는 다음과 같은 방식이 사용된다.

* *Subclass and Override Method*
* *Extract Interface*나 *Extract Implementer* (의존성이 광범위할 경우)

전역 의존성 문제를 제대로 해결하고 싶다면 *Introduce Static Setter* 대신 다음 기법을 사용하라.

* *Parameterized Method*: (단점) 메써드 개수가 많아지므로 클래스를 이해하기 어려워질 수도 있음.
* *Parameterized Constructor*: (단점) 필드가 개수가 많아짐. 객체를 생성하는 쪽에서도 생성자에 전달할 객체에 접근할 수 있어야 함.

만약 어떤 전역 변수가 정말 거의 모든 곳에서 사용되고 있다면, 그것은 코드에 계층 구조가 없기 때문일 것이다. 다음 내용을 참고하라.

* 15장, *My Application Is All API Calls*
* 17장, *My application Has No Structure*

## 끔찍한 *Include* 의존성

(C++) 테스트 *harness* 내에서 다루기 매우 어려운 라이브러리를 *include* 해야 하는 경우.

테스트 대상이 필요로 하는 심볼에 대해 별도의 테스트용 정의를 작성하는 방법을 사용할 수 있다. 나아가 이러한 정의들만 모아놓은 헤더 파일을 만들어 테스트 코드에서 재활용할 수도 있다.

하지만 다음과 같은 단점이 있기 때문에 거대한 클래스에 매우 심각한 의존성 문제가 있을 때만 사용하는 것이 좋다.

* 별도의 프로그램으로 빌드해야 함.
* 실제로는 의존성을 제거한 게 아님.
* 별도의 테스트용 정의를 계속 유지해야 함.

## 양파 같은 생성자 파라미터

어떤 객체 생성자에 넘겨줄 파라미터를 생성하기 위해 그 생성자에 넘겨줄 파라미터를 생성해야 하고, 그 파라미터 객체를 생성하기 위해 그 생성자에 넘겨줄 파라미터를 ...

테스트 시나리오 상 쓰임새가 없는 파라미터라면 과감히 *Null*을 넘긴다.

쓰임새가 있다면 가짜 객체를 생성하여 파라미터로 전달하기 위해 다음 기법을 사용한다:

* *Extract Interface*
* *Extract Implementer*

하지만 대상 클래스가 이미 다른 클래스를 확장하고 있다면 조금 더 고생이 필요하다. 언어마다 차이가 있는데, Java가 C++보다 해결하기 쉽다.

## 상위 타입 변수에도 대입되는 파라미터

인터페이스는 의존성을 끊는데 유용한 장치이지만, 계층 구조 상의 각 클래스마다 일대일로 인터페이스를 선언하게 되면 설계가 너저분해진다.

이런 경우에는 *Subclass and Override Method* 기법을 이용하여 테스트에만 사용할 서브클래스 객체를 만들어 생성자에 넘겨준다.

단순히 일부 메써드를 오버라이드 하는 것만으로는 테스트를 방해하는 의존성을 제거할 수 없는 경우에는 해당 의존성을 분리해내기 위해 메써드 추출을 먼저 수행해야 한다. 22장, *I Need to Change a Monster Method and I Can't Write Tests for It*의 내용을 참고하라.
