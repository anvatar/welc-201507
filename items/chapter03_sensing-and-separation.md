# 3장. 감지하기와 분리하기

의존성 끊기를 하는 두 가지 큰 이유

* 감지하기: 관심 영역의 코드가 출력하는 값에 접근하기 위해
* 분리하기: 테스트 도구 안에서 테스트하기 위해

분리 방식은 다양하다: 25장 참고

반면에 감지하기에는 거의 한 가지 방법 밖에 없다: *fake collaborator*

## *Fake Collaborators*

어떤 코드를 따로 떼어 실행하고 어떻게 동작하는지 살피려면 보통 다른 부분과의 의존성을 끊어야 한다. 하지만 그 '다른 부분'이 코드 변경의 효과를 감지할 수 있는 유일한 지점일 때도 있다.

### *Fake* 객체

테스트 대상인 클래스의 *collaborator*를 흉내내는 객체.

*Collaborator*로부터 인터페이스를 추출하고 이를 구현한 *fake* 객체를 테스트 대상 클래스와 연동시킨다. *Fake* 객체의 내부를 조사함으로써 테스트 대상 클래스의 동작을 파악한다.

### *Fake* 객체의 두 가지 측면

테스트 대상 클래스는 상위 인터페이스로서의 *fake* 객체를 보고, 테스트 코드는 구현 클래스로서의 *fake* 객체를 본다.

### *Fakes*의 정수(Distilled)

19장, *My Project is Not Object-Oriented. How Do I Make Safe Changes?* - 객체지향 언어가 아닌 경우에는 '가짜' 함수를 제공

### *Mock* 객체

내부에서 *assertion*을 수행하는 *fake collaborator*

*Mock* 객체에 기대되는 메써드 호출을 명시하고 테스트 대상 클래스가 *mock* 객체를 사용하게 한 다음, 기대했던 메써드 호출이 있었는지를 *mock* 객체가 스스로 판단

*Mock* 객체 프레임워크가 모든 언어에 존재하는 것은 아니며, 대부분의 경우 *fake* 객체만으로도 충분한 테스트가 가능하다.
