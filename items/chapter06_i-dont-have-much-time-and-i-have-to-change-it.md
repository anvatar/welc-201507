# 6장. 시간이 없는데 변경은 해야 해요
*(I Don’t Have Much Time and I Have To Change It)*

의존성을 끊고 테스트를 작성하는 것이 길게 보면 시간을 버는 길이다.

* 언제 투자 비용을 회수할 수 있나? : 비슷한 시기에 일어나는 변경들은 어느 정도 모여있기 마련이므로 오늘 작업하는 부분 주변을 잘 정비해 두면 곧 그 혜택을 볼 수 있다.

일정의 압박 속에서 의존성 끊고 테스트 작성하기:

* 레거시 코드를 다룰 때는 어떤 요구사항에 대해 유의미한 예측을 하기 힘들다. =\> 16장. *I Don't Understand the Code Well Enough to Change It*
* 상황의 압박 때문에 사기가 떨어질 때: 24장. *We Feel Overwhelmed. It Isn't Going to Get Any Better*
* 지금 당장 어떤 클래스를 변경해야 한다면, 그 클래스의 인스턴스를 테스트 도구(harness) 안에서 생성해 보아라. 생성하기 힘들다면:
	* 9장. *I Can't Get This Class into a Test Harness*
	* 10장. *I Can't Run This Method in a Test Harness*

그래도 안 된다면 필요한 변경을 잘 분석하여 기존 코드를 수정하는 대신 새로운 코드를 작성하는 것으로 문제를 해결한다.

## *Sprout Method*

절차

1. 코드 변경이 필요한 지점을 찾는다.
1. 단일 지점에 일련의 구문을 추가하여 문제를 해결할 수 있다면, 해당 로직을 수행하는 별도 메써드를 호출하는 코드를 작성한 뒤 주석 처리한다.
1. 새로 작성할 메써드의 파라미터와 리턴 값을 결정한다.
1. 새로 작성할 메써드를 TDD로 개발한다.
1. 앞에서 주석 처리해뒀던 메써드 호출을 주석 해제한다.

해당 클래스의 인스턴스를 생성하기가 너무 어려울 정도로 의존성이 얽혀있을 때:

* *Pass Null* 기법을 사용하거나,
* *Sprout Method*를 public static으로 선언

장단점

* (단점) 기존 메써드와 클래스는 전혀 개선되지 않는다. 새로 작성한 메써드를 호출하는 기존 코드는 테스트되지 않았다.
* (장점) 새 코드와 기존 코드 간에 경계가 분명하므로 정확성을 검증하기 쉽다.

## *Sprout Class*
