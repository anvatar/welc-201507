# 6장. 시간이 없는데 변경은 해야 해요
*(I Don’t Have Much Time and I Have To Change It)*

의존성을 끊고 테스트를 작성하는 것이 길게 보면 시간을 버는 길이다.

* Q: 언제 투자 비용을 회수할 수 있나?
* A: 비슷한 시기에 일어나는 변경들은 어느 정도 모여있기 마련이므로 오늘 작업하는 부분 주변을 잘 정비해 두면 곧 그 혜택을 볼 수 있다.

일정의 압박 속에서 의존성 끊고 테스트 작성하기:

* 레거시 코드를 다룰 때는 어떤 요구사항에 대해 유의미한 예측을 하기 힘들다. =\> 16장. *I Don't Understand the Code Well Enough to Change It*
* 상황의 압박 때문에 사기가 떨어질 때: 24장. *We Feel Overwhelmed. It Isn't Going to Get Any Better*
* 지금 당장 어떤 클래스를 변경해야 한다면, 그 클래스의 인스턴스를 테스트 도구(harness) 안에서 생성해 보아라. 생성하기 힘들다면:
	* 9장. *I Can't Get This Class into a Test Harness*
	* 10장. *I Can't Run This Method in a Test Harness*

그래도 안 된다면 필요한 변경을 잘 분석하여 기존 코드를 수정하는 대신 새로운 코드를 작성하는 것으로 문제를 해결한다.

* 이 장에서 소개하는 기법들을 계속 사용하다보면, 기존 코드에 대해 더 잘 이해하게 되어 두려움을 덜 갖고 작업할 수 있게 될 것이다.

## *Sprout Method*

변경 지점의 메써드를 직접 수정하는 것이 위험해 보이거나, 메써드를 개념적으로 복잡하게 만들 경우. 새로운 메써드에 필요한 로직을 작성하고 기존 메써드에서 새 메써드를 호출한다.

해당 클래스의 인스턴스를 생성하기가 너무 어려울 정도로 의존성이 얽혀있을 때:

* *Pass Null* 기법을 사용하거나,
* *Sprout Method*를 public static으로 선언

장단점

* (단점) 기존 메써드와 클래스는 전혀 개선되지 않는다. 새로 작성한 메써드를 호출하는 기존 코드는 테스트되지 않았다.
* (장점) 새 코드와 기존 코드 간에 경계가 분명하므로 정확성을 검증하기 쉽다.

## *Sprout Class*

테스트 *harness* 내에서 변경 지점의 클래스의 객체를 생성할 수 없어서 *Sprout Method* 기법을 이용할 수 없을 때. 새로운 클래스를 생성하고 기존 클래스에서 사용.

장단점

* (장점) C++에서 사용하면, 기존 헤더 파일을 수정할 필요가 없다.
* (단점) 설계에 새로운 개념이 추가된다.
    * 기존 코드 조각과의 유사성을 찾아내 공통 개념으로 추출할 수 있으면 좋다.

## 메써드 감싸기 (*Wrap Method*)

최초에는 한 가지 일을 하기 위해 만든 메써드에, 단지 동작 시점이 같다는 이유로 다른 코드를 추가(*temporal coupling*)하는 것은 바람직하지 않다.

장점

* 기존 메써드의 내용을 전혀 손대지 않으며, 기존 기능과 신규 기능을 명시적으로 분리한다.

두 가지 방식이 있다.

1. 기존 메써드의 이름을 다른 것으로 바꾸고, 기존 메써드의 원래 이름과 시그너쳐까지 동일한 새로운 메써드를 정의하여 그 안에서 기존 메써드를 사용(호출).
    *  호출하는 쪽에서는 변경을 몰라도 되는 효과
    *  기능에 변화가 없는 기존 메써드에 새로운 이름을 붙여야 하는 단점
1. 추가 기능을 별도 private 메써드로 구현하고, 기존 메써드와 추가 기능 메써드를 모두 호출하는 새로운 public 메써드 정의.
    * 호출하는 쪽에서 기존 메써드와 새로운 메써드 중 선택하여 사용.

저자는 주로 신규 기능이 기존 것만큼 중요할 경우에 *Sprout Method* 대신 이 기법을 사용한다.

## 클래스 감싸기 (*Wrap Class*)

기존 클래스를 수정하지 않고 새로운 행위를 시스템에 추가한다.

* 기존 클래스를 호출하는 곳이 많다면 *decorator* 패턴 사용
* 그렇지 않다면 특정 행위만 감싸는 *wrapper* 클래스 작성한 뒤 필요한 곳에서 호출

저자는 주로 다음과 같은 상황에서 *Sprout Class* 대신 이 기법을 사용한다.

* 추가하려는 행위가 기존 것과 완전히 독립적일 때
* 기존 클래스가 지나치게 거대해서 더 이상 상태를 악화시키고 싶지 않을 때
    * 20장. *This Class Is Too Big and I Don't Want It to Get Any Bigger*

기존 클래스의 객체를 테스트 *harness* 내에서 생성할 수 없다면 해당 클래스에 *Extract Implementer*나 *Extract Interface*를 적용한 뒤, *wrapper* 클래스가 추출한 인터페이스를 구현하게 한다.

시스템 내 새로운 개념으로 발전시킬 수 있을지, *wrapper* 클래스가 갖는 책임의 변화를 지켜보는 것이 좋다.
